/**
 * Compatibility tests against python-chess reference files.
 * 
 * These tests compare the output of our parser against the JSON reference
 * files generated by python-chess to ensure tree structures match.
 */

import { test, suite } from "uvu";
import assert from "uvu/assert";
import * as fs from "fs";
import * as path from "path";
import { readGame, readGames, Game, GameNode } from "../src";

// =============================================================================
// Reference File Types
// =============================================================================

interface ReferenceMove {
  uci: string;
  san: string;
  from: number;
  to: number;
  promotion: number | null;
  drop: number | null;
}

interface ReferenceNode {
  move: ReferenceMove | null;
  fen: string;
  comment: string | null;
  starting_comment: string | null;
  nags: number[];
  clock: number | null;
  eval: number | null;
  arrows: Array<{ color: string; tail: number; head: number }>;
  shapes: Array<{ color: string; square: number }>;
  is_end: boolean;
  is_mainline: boolean;
  is_main_variation: boolean;
  variations: ReferenceNode[];
  variation_index?: number;
}

interface ReferenceGame {
  headers: Record<string, string>;
  starting_fen: string;
  comment: string | null;
  starting_comment: string | null;
  nags: number[];
  is_end: boolean;
  variations: ReferenceNode[];
  mainline: Array<{ uci: string; san: string; fen_after: string }>;
  total_nodes: number;
}

interface ReferenceFile {
  source_file: string;
  games_count: number;
  games: ReferenceGame[];
}

// =============================================================================
// Helper Functions
// =============================================================================

function loadReferenceFile(pgnName: string): ReferenceFile | null {
  const refPath = path.join(__dirname, "reference-trees", `${pgnName}.json`);
  if (!fs.existsSync(refPath)) {
    return null;
  }
  return JSON.parse(fs.readFileSync(refPath, "utf-8"));
}

function loadPgnFile(pgnName: string): string | null {
  // Try multiple locations for PGN files
  const locations = [
    path.join(__dirname, "..", "pgns", `${pgnName}.pgn`),  // Project root pgns folder
    path.join(__dirname, "pgns", `${pgnName}.pgn`),  // Local test folder
  ];
  
  for (const pgnPath of locations) {
    if (fs.existsSync(pgnPath)) {
      return fs.readFileSync(pgnPath, "utf-8");
    }
  }
  return null;
}

function compareMainline(game: Game, refGame: ReferenceGame): void {
  const mainline: Array<{ uci: string; san: string; fen: string }> = [];
  
  for (const node of game.mainline()) {
    mainline.push({
      uci: node.move?.uci() ?? "",
      san: node.san() ?? "",
      fen: node.fen(),
    });
  }
  
  assert.is(
    mainline.length,
    refGame.mainline.length,
    `Mainline length mismatch: got ${mainline.length}, expected ${refGame.mainline.length}`
  );
  
  for (let i = 0; i < mainline.length; i++) {
    const got = mainline[i];
    const expected = refGame.mainline[i];
    
    assert.is(
      got.uci,
      expected.uci,
      `Move ${i + 1} UCI mismatch: got ${got.uci}, expected ${expected.uci}`
    );
    
    // Note: FEN comparison might differ slightly due to en passant/fullmove number
    // so we only check if the position (first part) matches
    const gotPos = got.fen.split(" ")[0];
    const expectedPos = expected.fen_after.split(" ")[0];
    assert.is(
      gotPos,
      expectedPos,
      `Move ${i + 1} position mismatch: got ${gotPos}, expected ${expectedPos}`
    );
  }
}

function countNodes(node: GameNode): number {
  let count = 1;
  for (const child of node.variations) {
    count += countNodes(child);
  }
  return count;
}

function compareTreeStructure(game: Game, refGame: ReferenceGame): void {
  // Compare total node count
  const gotCount = game.countNodes();
  assert.is(
    gotCount,
    refGame.total_nodes,
    `Total nodes mismatch: got ${gotCount}, expected ${refGame.total_nodes}`
  );
  
  // Compare headers
  for (const [key, value] of Object.entries(refGame.headers)) {
    // Skip some headers that python-chess normalizes differently
    if (key === "Result" && value === "*") continue;
    
    const gotValue = game.headers.get(key);
    if (gotValue !== undefined) {
      assert.is(
        gotValue,
        value,
        `Header "${key}" mismatch: got "${gotValue}", expected "${value}"`
      );
    }
  }
  
  // Compare root game comment
  if (refGame.comment) {
    // python-chess might include trailing spaces or normalize whitespace
    const gotComment = game.comment.trim();
    const expectedComment = refGame.comment.trim();
    assert.ok(
      gotComment.includes(expectedComment) || expectedComment.includes(gotComment),
      `Game comment mismatch`
    );
  }
}

// =============================================================================
// Test Suites
// =============================================================================

// Get list of reference files
const refDir = path.join(__dirname, "reference-trees");
const refFiles = fs.existsSync(refDir)
  ? fs.readdirSync(refDir).filter(f => f.endsWith(".json")).map(f => f.replace(".json", ""))
  : [];

const compatTests = suite("Python-chess compatibility tests");

// Create a test for each reference file
for (const pgnName of refFiles) {
  compatTests(`should match python-chess for ${pgnName}`, () => {
    const refFile = loadReferenceFile(pgnName);
    if (!refFile) {
      console.log(`  Skipping ${pgnName}: no reference file`);
      return;
    }
    
    const pgnContent = loadPgnFile(pgnName);
    if (!pgnContent) {
      console.log(`  Skipping ${pgnName}: no PGN file found`);
      return;
    }
    
    const games = readGames(pgnContent);
    
    assert.is(
      games.length,
      refFile.games_count,
      `Game count mismatch for ${pgnName}`
    );
    
    for (let i = 0; i < games.length; i++) {
      const game = games[i];
      const refGame = refFile.games[i];
      
      // Compare mainline
      try {
        compareMainline(game, refGame);
      } catch (e: any) {
        throw new Error(`${pgnName} game ${i + 1}: ${e.message}`);
      }
      
      // Compare tree structure
      try {
        compareTreeStructure(game, refGame);
      } catch (e: any) {
        throw new Error(`${pgnName} game ${i + 1}: ${e.message}`);
      }
    }
  });
}

compatTests.run();

// =============================================================================
// Additional Structural Tests
// =============================================================================

const structureTests = suite("Tree structure tests");

structureTests("should correctly parse complex nested variations", () => {
  // Game with multiple levels of nesting
  const pgn = `
    1. e4 e5 (1... c5 2. Nf3 (2. d4 cxd4) d6) 2. Nf3 Nc6 
    (2... Nf6 3. Nxe5 (3. Bc4 Nxe4)) 3. Bb5 *
  `;
  
  const game = readGame(pgn);
  assert.ok(game);
  
  // Count all nodes
  const nodeCount = game!.countNodes();
  assert.ok(nodeCount > 5);
  
  // Verify structure
  const e4 = game!.variations[0];
  assert.is(e4.variations.length, 2);
  
  const c5 = e4.variations[1];
  assert.is(c5.variations.length, 2);
});

structureTests("should preserve FEN at each node", () => {
  const game = readGame("1. e4 e5 2. Nf3 Nc6 *");
  assert.ok(game);
  
  // Check starting position
  const startFen = game!.board().fen();
  assert.ok(startFen.startsWith("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"));
  
  // Check position after each move
  const nodes = [...game!.mainline()];
  assert.is(nodes.length, 4);
  
  // After 1. e4
  const afterE4 = nodes[0].fen();
  assert.ok(afterE4.includes("4P3"));
  
  // After 1... e5
  const afterE5 = nodes[1].fen();
  assert.ok(afterE5.includes("4p3"));
  
  // After 2. Nf3
  const afterNf3 = nodes[2].fen();
  assert.ok(afterNf3.includes("5N2"));
  
  // After 2... Nc6
  const afterNc6 = nodes[3].fen();
  assert.ok(afterNc6.includes("2n5"));
});

structureTests("should handle games from a position (FEN header)", () => {
  const pgn = `
    [FEN "r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 2 3"]
    [SetUp "1"]
    
    3. Bb5 a6 4. Ba4 Nf6 *
  `;
  
  const game = readGame(pgn);
  assert.ok(game);
  
  // Board should start from the FEN position
  const board = game!.board();
  assert.is(board.fullmoveNumber, 3);
  
  // Mainline should start from move 3
  const mainline: string[] = [];
  for (const node of game!.mainline()) {
    mainline.push(node.san() ?? "");
  }
  assert.equal(mainline, ["Bb5", "a6", "Ba4", "Nf6"]);
});

structureTests.run();

